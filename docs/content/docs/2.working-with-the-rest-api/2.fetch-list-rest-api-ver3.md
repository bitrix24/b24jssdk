---
title: FetchListV3.make
description: 'Returns an AsyncGenerator that allows processing data from list methods of Bitrix24 REST API version 3 as it is received without loading the entire array into memory at once. This is especially useful when working with very large volumes of data.'
category: 'actions'
restApiVersion: 'rest-api-ver3'
navigation:
  title: FetchList
links:
  - label: FetchListV3
    iconName: GitHubIcon
    to: https://github.com/bitrix24/b24jssdk/blob/main/packages/jssdk/src/core/actions/v3/fetch-list.ts
  - label: SdkError
    iconName: GitHubIcon
    to: https://github.com/bitrix24/b24jssdk/blob/main/packages/jssdk/src/core/sdk-error.ts
  - label: Async Generator
    iconName: MdnwebdocsIcon
    to: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator
---

::warning
We are still updating this page. Some data may be missing here — we will complete it shortly.
::

## Overview

When you need to process large volumes of data from list methods of REST API version 3 in parts (chunks), use `FetchListV3.make()`{lang="ts-type"}.

This method implements a fast algorithm for iterating over large data sets without loading all data into memory at once. Each iteration returns the next page/batch of results until all data is received.

```ts
// Basic usage
const generator = $b24.actions.v3.fetchList.make({
  method: 'main.eventlog.list',
  params: {
    filter: [
      ['userId', '=', 1]
    ],
    select: ['id', 'userId']
  },
  idKey: 'id',
  customKeyForResult: 'items',
  requestId: 'unique-request-id',
  limit: 600
})

for await (const chunk of generator) {
  // Process chunk (e.g., save to database, analyze, etc.)
  console.log(`Processing ${chunk.length} items`)
}
```

### When to Use FetchListV3.make()

1. **Very large data volumes**: When the number of records is in the thousands or tens of thousands.
2. **Stream processing**: When data needs to be processed as it arrives.
3. **Long operations**: When processing each record requires significant time.

## Method Signature

```ts-type
make<T = unknown>(
  options: ActionFetchListV3
): AsyncGenerator<T[]>
```

### Parameters

The `options` object contains the following properties:

| Parameter | Type | Required | Description |
|----|----|----|----|
| **`method`** | `string`{lang="ts-type"} | Yes | REST API method name that returns a data list (e.g., `crm.contact.list`, `tasks.task.list`). |
| **`params`** | `Omit<TypeCallParams, 'pagination'>`{lang="ts-type"} | No | Request parameters, excluding the `pagination` parameter, as the method is designed to retrieve all data in a single call. Use `filter`, `order`, `select` to control the selection. |
| **`idKey`** | `string`{lang="ts-type"} | No | Name of the field containing the unique element identifier. Default: `'id'`. Can also be another field depending on the REST API data structure. |
| **`customKeyForResult`** | `string`{lang="ts-type"} | Yes | Custom key indicating that the REST API response will be selected by this field. For example: `items` for a list of CRM elements. |
| **`requestId`** | `string`{lang="ts-type"} | No | Unique request identifier for tracking. Used for request deduplication and debugging. |
| **`limit`** | `number`{lang="ts-type"} | No | How many records to retrieve at a time. Default is `50`. Maximum is `1000`. |

### Return Value

`AsyncGenerator<T[]>`{lang="ts-type"} — an asynchronous generator that returns data chunks as arrays of type `T`.

Each iteration of the generator returns:

- An array of elements (chunk) with up to `options.limit` records.
- The generator completes when all data is received.

## Key Concepts

### AsyncGenerator vs Promise

Unlike `CallListV3.make()`{lang="ts-type"}, which returns a `Promise`{lang="ts-type"} with all data at once, `FetchListV3.make()`{lang="ts-type"} returns an asynchronous generator:

| Aspect | `CallListV3.make()` | `FetchListV3.make()` |
|----|----|----|
| **Return Value** | `Promise<Result<T[]>>` | `AsyncGenerator<T[]>` |
| **Memory** | Loads all data into memory | Processes data in parts |
| **Usage** | `await response.getData()` | `for await (const chunk of generator)` |
| **Suitable for** | Small to medium data volumes | Very large data volumes |

### Performance Optimization

The method implements the [Bitrix24 recommended algorithm](https://apidocs.bitrix24.com/settings/performance/huge-data.html) for efficient work with large data volumes:

1. **Filtering by increasing id**: Each subsequent query uses a `>id` filter with the id of the last retrieved element.
2. **Stream processing**: Data is processed as it is received, saving memory.
3. **Automatic data end detection**: Requests stop when an empty array is received or the number of elements is less than the page size (`options.limit`).

### REST API v3 Response Structure

::note
The `customKeyForResult`{lang="ts-type"} parameter is retained for backward compatibility. In the future, after analyzing real usage, a decision will be made regarding its necessity.
::

In REST API version 3, various methods return data in the same structures:

- **Grouped array**: `{ result: { items: [...] } }`{lang="ts-type"}

The `customKeyForResult`{lang="ts-type"} parameter allows you to specify the key where the data is located in the response.

### Limitations

- **Page size**: Bitrix24 REST API version 3 limitation — maximum `1000` records per request.
- **Sorting**: The method always adds sorting by `idKey` in ascending order for correct pagination.
- **Only for list methods**: Intended only for methods that return data arrays.

## Error Handling

Since the method returns an asynchronous generator, errors are handled differently than in `CallListV3.make()`{lang="ts-type"}:

```ts
try {
  const generator = $b24.actions.v3.fetchList.make({
    method: 'some.method',
    params: { /* some_params */ },
    idKey: 'id',
    customKeyForResult: 'items',
    requestId: 'unique-request-id',
    limit: 600
  })

  for await (const chunk of generator) {
    // Process chunk (e.g., save to database, analyze, etc.)
    console.log(`Processing ${chunk.length} items`)
  }
} catch (error) {
  // Handling error
  if (
    error instanceof SdkError
    && error.code === 'JSSDK_CORE_B24_FETCH_LIST_METHOD_API_V3'
  ) {
    console.error(`${error.message}`, { code: error.code })
  } else {
    console.error('Some error', error)
  }
}
```

## Examples

### Step-by-step processing of a large number of Event Log Items

```ts [ProcessMainEventLogItems.ts]
import { B24Hook, LoggerFactory, Text, SdkError, AjaxError } from '@bitrix24/b24jssdk'

type MainEventLogItem = {
  id: number
  userId: number
}

const devMode = typeof import.meta !== 'undefined' && (import.meta.dev || import.meta.env?.DEV)
const $logger = LoggerFactory.createForBrowser('Example:ProcessMainEventLogItems', devMode)
const $b24 = B24Hook.fromWebhookUrl('https://your_domain.bitrix24.com/rest/1/webhook_code/')

async function processMainEventLogItem(): Promise<void> {
  let batchNumber = 0
  let totalItems = 0

  const sixMonthAgo = new Date()
  sixMonthAgo.setMonth((new Date()).getMonth() - 6)
  sixMonthAgo.setHours(0, 0, 0)
  
  const requestId = 'some-main-event-log-item-list'
  
  try {
    const generator = $b24.actions.v3.fetchList.make<MainEventLogItem>({
      method: 'main.eventlog.list',
      params: {
        filter: [
          ['timestampX', '>=', Text.toB24Format(sixMonthAgo)] // created at least 6 months ago
        ],
        select: ['id', 'userId']
      },
      idKey: 'id',
      customKeyForResult: 'items',
      requestId,
      limit: 60
    })
    
    for await (const chunk of generator) {
      batchNumber++
      totalItems += chunk.length

      $logger.info(`Processing batch #${batchNumber}`, {
        batchSize: chunk.length,
        totalSoFar: totalItems
      })
      
      // Example: saving to database
      await saveToDatabase(chunk)
      
      // Example: sending to message queue
      await sendToMessageQueue(chunk)
    }
    
    $logger.notice(`Processed ${totalItems} elements in ${batchNumber} batches`)
  } catch (error) {
    if (error instanceof SdkError) {
      $logger.error(`Processing error: ${error.message}`, {
        code: error.code,
        batchNumber,
        totalItems
      })
    } else {
      $logger.error('Unknown error', { error, batchNumber, totalItems })
    }
    throw error
  }
}

// Helper functions
// Database save implementation
async function saveToDatabase(items: MainEventLogItem[]): Promise<void> {
  await new Promise(resolve => setTimeout(resolve, 100)) // Simulation
}

// Message queue send implementation
async function sendToMessageQueue(items: MainEventLogItem[]): Promise<void> {
  await new Promise(resolve => setTimeout(resolve, 50)) // Simulation
}

// Usage
try {
  await processMainEventLogItem()
} catch (error) {
  $logger.critical('A problem occurred', { error })
}
```

## Alternatives and Recommendations

* **Chunk size**: Bitrix24 REST API version 3 always returns up to 50 records per request.
* **Optimal concurrency**: When processing data from the generator, limited concurrency (3-5 simultaneous operations) is recommended.
* **Error handling**: Always handle errors inside the `for await...of` loop to prevent the entire process from stopping.
* **Progress monitoring**: Implement progress logging for long-running operations.

* **For sequential requests**: Use [`Call`](/docs/working-with-the-rest-api/call-rest-api-ver3/) for single calls.
* **For batch operations:** Use [`Batch`](/docs/working-with-the-rest-api/batch-rest-api-ver3/) to execute up to 50 commands in a single request.
* **On the client-side (browser):** Use the built-in [`B24Frame`](/docs/getting-started/installation/vue/#init) object.
