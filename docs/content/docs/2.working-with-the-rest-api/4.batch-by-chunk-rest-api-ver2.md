---
title: BatchByChunkV2.make
description: 'Method for executing batch requests with automatic chunking for any number of commands. Automatically splits large command sets into batches of 50 and executes them sequentially. Use only arrays of tuples or arrays of objects.'
category: 'actions'
restApiVersion: 'rest-api-ver2'
navigation:
  title: BatchByChunk
links:
  - label: BatchByChunkV2
    iconName: GitHubIcon
    to: https://github.com/bitrix24/b24jssdk/blob/main/packages/jssdk/src/core/actions/v2/batch-by-chunk.ts
  - label: AjaxResult
    iconName: GitHubIcon
    to: https://github.com/bitrix24/b24jssdk/blob/main/packages/jssdk/src/core/http/ajax-result.ts
  - label: AjaxError
    iconName: GitHubIcon
    to: https://github.com/bitrix24/b24jssdk/blob/main/packages/jssdk/src/core/http/ajax-error.ts
  - label: SdkError
    iconName: GitHubIcon
    to: https://github.com/bitrix24/b24jssdk/blob/main/packages/jssdk/src/core/sdk-error.ts
---

::warning
We are still updating this page. Some data may be missing here — we will complete it shortly.
::

## Overview

Use `BatchByChunkV2.make()`{lang="ts-type"} to execute a large number of REST API requests with automatic batching.

The method returns a `Promise` with a `Result<T[]>`{lang="ts-type"} object containing the combined results of all successful commands.

This is especially useful for:

* Bulk creating or updating records
* Exporting large volumes of data via batch requests
* Performing complex operations that require many different API calls

```ts
// Basic usage
import { B24Hook, EnumCrmEntityTypeId } from '@bitrix24/b24jssdk'

// We create 150 deals (they will be divided into 3 chunks of 50 deals each)
const commands = Array.from({ length: 150 }, (_, i) => [
  'crm.item.add',
  { entityTypeId: EnumCrmEntityTypeId.deal, fields: { title: `Deal ${i + 1}` } }
])

const response = await $b24.actions.v2.batchByChunk.make({
  calls: commands,
  options: {
    isHaltOnError: true,
    requestId: 'unique-request-id'
  }
})
```

## Method Signature

```ts-type
make<T = unknown>(
  options: ActionBatchByChunkV2
): Promise<Result<T[]>>
```

### Parameters

The `options` object contains the following properties:

| Parameter | Type | Required | Description |
|----|----|----|----|
| **`calls`** | `BatchCommandsArrayUniversal \| BatchCommandsObjectUniversal`{lang="ts-type"} | Yes | Commands to execute in the batch. Supports several [formats](#command-formats-optionscalls). **Named commands are not supported**. |
| **`options`** | `Omit<IB24BatchOptions, 'returnAjaxResult'>`{lang="ts-type"} | No | [Additional options](##batch-request-options-optionsoptions) for batch request execution. |

### Command Formats (`options.calls`)

#### 1. Array of tuples (`BatchCommandsArrayUniversal`)
```ts
calls: [
  ['method1', params1],
  ['method2', params2],
  // ...
]
```

#### 2. Array of objects (`BatchCommandsObjectUniversal`)
```ts
calls: [
  { method: 'method1', params: params1 },
  { method: 'method2', params: params2 },
  // ...
]
```

### Batch Request Options (`options.options`)

| Option | Type | Default | Description |
|----|----|----|----|
| **`isHaltOnError`** | `boolean`{lang="ts-type"} | `true` | Whether to stop execution on the first error in a chunk. |
| **`requestId`** | `string`{lang="ts-type"} | — | Unique request identifier for tracking. Used for request deduplication and debugging. |

### Return Value

`Promise<CallBatchResult<T>>`{lang="ts-type"} — a promise that resolves to a `Result<T[]>`{lang="ts-type"} object.

Important features:

* **Only successful results**: Only successfully executed commands are included in the array.
* **Combined array**: All results from all chunks are combined into a single array.
* **Order preserved**: Results are preserved in the same order as the original commands.

## Error Handling

The method will split all commands into chunks and begin executing them one by one using [`Batch`{lang="ts-type"}](/docs/working-with-the-rest-api/batch-rest-api-ver2/).

If an error occurs when calling `Batch`, it will be stored in `Result`{lang="ts-type"}, and the loop will continue executing.

The `isHaltOnError`{lang="ts-type"} parameter affects the behavior of the callBatch method:

When `isHaltOnError = false`, commands are executed even if some have completed with an error.
When `isHaltOnError = true` (the default), package execution is aborted if an error occurs in any of the commands.

Always check the result using `isSuccess` and handle errors:

```ts
const calls = Array.from({ length: 150 }, (_, i) => [
  'crm.item.add',
  { entityTypeId: EnumCrmEntityTypeId.deal, fields: { title: `Deal ${i + 1}` } }
])
const response = await $b24.actions.v2.batchByChunk.make({
  calls,
  options: {
    isHaltOnError: true,
    requestId: 'unique-request-id'
  }
})

if (!response.isSuccess) {
  // Handling error
  console.error(new Error(`Error: ${response.getErrorMessages().join('; ')}`))
  return
}

// Working with a successful result
const data = response.getData()
```

## Examples

### Bulk CRM deal creation

```ts [BatchByChunkCrmItems.ts]
import type { AjaxResult } from '@bitrix24/b24jssdk'
import { B24Hook, EnumCrmEntityTypeId, LoggerFactory } from '@bitrix24/b24jssdk'

type Deal = {
  id: number
  title: string
  stageId: string
  opportunity: number
}

const devMode = typeof import.meta !== 'undefined' && (globalThis._importMeta_.env?.DEV || false)
const $logger = LoggerFactory.createForBrowser('Example:batchByChunkCrmItems', devMode)
const $b24 = B24Hook.fromWebhookUrl('https://your_domain.bitrix24.com/rest/1/webhook_code/')

async function addMultipleItems(needAdd: number, requestId: string): Promise<number[]> {
  const calls = Array.from({ length: needAdd }, (_, i) => [
    'crm.item.add',
    {
      entityTypeId: EnumCrmEntityTypeId.deal,
      fields: {
        title: `Automatic deal #${i + 1}`,
        stageId: 'NEW',
        opportunity: Math.floor(Math.random() * 10000) + 1000
      }
    }
  ])
  
  const response = await $b24.actions.v2.batchByChunk.make<{ item: Deal }>({
    calls,
    options: {
      isHaltOnError: true,
      requestId
    }
  })
  
  if (!response.isSuccess) {
    throw new Error(`Problem: ${response.getErrorMessages().join('; ')}`)
  }
  
  const resultData = (response as Result<AjaxResult<{ item: Deal }>[]>).getData()!
  const results: number[] = []
  resultData.forEach((resultRow, index) => {
    if (resultRow.isSuccess) {
      results.push(resultRow.item.id)
    }
  })

  return results
}

// Usage
const requestId = 'batch/crm.item.add'
try {
  const needAdd = 120
  const items = await addMultipleItems(needAdd, requestId)
  
  $logger.info(`Retrieved ${items.length} items`, {
    expected: needAdd,
    retrieved: items.length,
    items
  })
} catch (error) {
  if (error instanceof AjaxError) {
    $logger.critical(error.message, { requestId, code: error.code })
  } else {
    $logger.alert('Problem', { requestId, error })
  }
}
```

## Alternatives and Recommendations

* **For sequential requests**: Use [`Call`](/docs/working-with-the-rest-api/call-rest-api-ver2/) for single calls.
* **For working with lists**: Use [`CallList`](/docs/working-with-the-rest-api/call-list-rest-api-ver2/) for retrieving large volumes of data.
* **For step-by-step processing**: Use [`FetchList`](/docs/working-with-the-rest-api/fetch-list-rest-api-ver2/) for processing data as it arrives.
* **For batch operations:** Use [`Batch`](/docs/working-with-the-rest-api/batch-rest-api-ver2/) to execute up to 50 commands in a single request.
* **On the client-side (browser):** Use the built-in [`B24Frame`](/docs/getting-started/installation/vue/#init) object.
